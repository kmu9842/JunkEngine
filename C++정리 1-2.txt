포인터와 동적 메모리

동적 메모리는 컴파일 시점에 크기를 정할 수 없는 데이터를 이용할 수 있게 해준다.


스택과 힙

C++에서 사용하는 메모리는 스택과 힙 두 가지로 나누어진다. 

스택 메모리는 쌓여 있는 카드에 비유할 수 있다.
여기서 가장 위에 놓인 카드는 프로그램의 상태를 나타냄 -> 실행 중인 함수, 그 함수의 로컬 변수가
제일 위에 위치함

스택 프레임은 각 함수 간 메모리 공간을 격리시키는 중요한 역할을 함.
ex)foo()함수에서 bar()함수를 호출하는동안 foo()함수의 로컬 변수들은 변하지 않음.
   bar()함수의 실행이 끝나고 리턴하면 bar()함수의 로컬 변수들은 bar()함수의 스택프레임과 함께 사라짐

힙 메모리는 실행 중인 함수나 스택 프레임과는 완전히 독립적인 메모리 영역이다.
함수의 호출과 리턴에 관계없이 항상 존재해야 하는 변수들이 위치됨.


동적 할당 배열

스택은 동작 방식 대문에 컴파일 시점에 크기가 결정되어야 함.
ex)
int arraysize = 8;
int array[arraysize]; // 컴파일 에러 발생

배열의 크기를 실행 시점에 동적으로 결정해야 한다면 동적 메모리를 이용해 
스택 대신 힙에 배열을 위치시킨다

동적 배열 할당 방법

int* array;
array = new int[arraySize];

new - C언어에서의 malloc()와 유사
new 명령은 파라미터 arraySize만큼 힙 메모리를 확보하여 그 주소 값을 포인터 변수에 대입해준다.
이를 이용해 포인터 변수 자체는 스택에 위치하고 있으나 동적으로 할당된 배열 데이터는 힙에 위치한다.

delete - C언어에서의 free()와 유사
동적으로 할당된 배열을 더는 사용하지 않는다면 수동적으로 힙 메모리에서 해제해야한다.
C++에서는 이 역할을 delete명령을 이용해 해제해 준다.
ex) delete [] array;
대괄호는 해당 메모리가 배열임을 표시해줌

new, new[]와 delete, delet[]는 각각 짝을 맞춰서 이용되어야 메모리 릭을 막을 수 있다.


스마트 포인터

스마트 포인터는 해당 객체에 대한 참조 스코프가 벗어나면 자동으로 메모리 해제를 수행함.
ex) int* array = new int[arraySize];
 -> unique_ptr<int[]> array(new int[arraySize]);


포인터의 이용

어떤 변수든 힙 메모리에 할당 가능함
ex) int *IntagerPointer = new int;

여기서 포인터는 정수 변수 하나가 위치한 주소를 가리킨다.
수를 대입시 포인터 자체는 변하지 않고, 포인터가 가리키는 메모리의 값이 바뀐다.
- 포인터는 이용되기 전에 반드시 메모리가 할당되어 초기화 되어야한다.

& 연산자
변수로부터 포인터를 얻는 연산자.
ex) int i = 8;
    int* p = &i; // 숫자 8을 값으로 가진 변수의 포인터 변수


구조체 참조하기

구조체를 참조하려면 먼저 값에 접근하기 위해 새역참조 연산자 *를 포인터에 붙이고, 이렇게
역참조된 변수에 .을 붙여서 구조체 내 각 필드를 선택한다
ex) Employee* a = getEmployee();
    cout << (*a).salary << endl;

구조체 역참조 연산자(->)를 활용할 경우
ex) Employee* a = getEmployee();
    cout << a->salary << endl;


값 전달

함수를 호출하면서 파라미터 전달을 위해 변수를 인자로 이용할 때 해당 변수의 주소가 아닌 값을
넘기게 됨. 이러한 방법을 "값에 의한 전달"이라고 함.

변수 대신 변수의 주소를 가리키는 포인터를 인자로 전달할 수도 있음. 포인터를 인자로 전달할 경우 
스택 프레임 안에 복사되어 저장되는 것이 변수의 주소가 되기 때문에 그 주소를 역참조 하여 
스택 프레임 밖에 있는 변수의 값을 변경하는 것이 가능해진다. 이것을 "참조에 의한 전달"이라고 한다.
C++에서는 참조형 변수를 지원한다.