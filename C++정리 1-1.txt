전처리 지시자 - 빌드의 첫단계인 전처리단계에서 사용되는 것으로 #문자로 시작한다.
		소스 파일이 컴파일될 수 있도록 준비하는 역할
		한 행에 한 지시자만 쓸 수 있음, #으로 시작함
		
전처리 지시자의 종류 - 	#include - 지정된 파일의 내용의 전문을 현재 소스 파일의 해당 지시자가 위치한곳에 삽입
				   <>의 경우 기본적으로 제공해주는 스탠다드 헤더를 부를 때 사용
			#define  - 매크로. 정의하다. 지시자 이후에 뒤따르는 모든 키워드를 value로 대체
			#ifdef   - 특정 키워드가 컴파일러 옵션으로 정의되어 있는지에 따라 해당 블록의 코드를 활성화/비활성화 시킴
			#ifndef 
			#if
			#else
			#endif 
			#undef	 - 매크로 정의를 해제, 이전에 정의된 매크로 정의를 무효화하고 새로 정의할 때 사용
			#pragma  - 특정 종류의 컴파일러에서만 지원되는 전처리 기능을 이용할때 사용
			
ex)
조건부 컴파일
#if 조건식1
	문장1;
#else 
	문장2;
#endif
			
warring!)
#define SQUARE1(x) x*x		(2+3)	->	11	->	2+3*2+3
#define SQUARE2(x) ((x)*(x))	(2+3)	->	25	->	(2+3)*(2+3)
#define은 행 맨 끝에 \ 사용해서 여러줄 사용가능


main()함수  - 	프로그램을 실행할 때 가장 먼저 호출되는 시작점 
	     	int타입 리턴값은 프로그램의 상태를 리턴
int main(int argc, char* argv[]) - argc는 실행시 명령줄에서 넘겨진 파라미터의 개수, argv는 각 파라미터의 문자열 값이 들어있음.
				   프로그램의 이름도 파라미터에 포함되어 제일 첫 번째 파라미터로 취급됨.


네임스페이스  - 코드 내에서 이름이 같은 변수명이나 함수명이 
		서로 충돌하는 문제를 해결하기 위해 고안되었음.


C++11이후의 변수 타입들(크기는 윈도우 기준)

int  		음수/양수 정수. 크기는 (4바이트)					
short(int)  	작은 음수/양수 (2바이트)						
long(int)  	long정수(4바이트)
long long(int)	long long정수. 최소 long보다 큼.(8바이트, C++11 추가)

unsigned int	0을 포함한 양수만 표현 가능한 정수(4바이트)
unsinged short(int)
unsinged long(int) (C++11추가)
unsinged long long(int)

float 		부동소수점 숫자	(4바이트)
double		배정도 정밀도 부동소수점 숫자. float이상의 정밀함. (8바이트)
long double	long 배정도 정밀도 부동소수점 숫자. double이상의 정밀함 (8바이트)

char		8비트 문자(1바이트)
char16_t	16비트 문자(2바이트, C++11추가)
char32_t	32비트 문자(4바이트, C++11추가)
wchar_t		와이드 문자(확장 문자)로 컴파일러에 따라 다름

bool		참 또는 거짓 논리타입(1바이트)
auto		컴파일러에 의해 자동으로 정해짐(C++11추가)
decltype(expr)	"expr"이 나타내는 타입과 같은 타입(C++11추가)


변수들의 서식문자

%d  - int
%ld - long
%hd - unsigned short
%u  - unsinged int
%o  - unsinged int 8진수
%x  - unsinged int 16진수
%f  - float, double
%lf - double
%c  - char
%s  - char*, string, CString


연산자

=  - 이항 연산자, 오른쪽의 값을 왼쪽에 있는 변수에 대입
!  - 단항 연산자, true,false값을 반전
+  - 사칙연산
- 
* 
/
%  - 나머지값을 구한다. MOD연산자라고도 함.
++ - 1 증가시키는 단항 연산자. ++i는 "사후 증가"가 적용되어 다음 라인부터 적용됨.
-- - 1 감소시키는 단항 연산자. 마찬가지로 사후 감소 적용.
+= - a = a(연산자)b의 축약형.
-=
*=
/=
%=
&  - 두 변수의 각 비트값에 AND연산
&= 
|  - 두 변수의 각 비트값에 OR연산
|=
<< - 왼쪽 변수의 비트 열을 오른쪽 값만큼 왼쪽 또는 오른쪽으로 시프트함
>>
<<=
>>=
^  - 두 변수의 각 비트 값에 배타적 논리합(EOR, A와 B의 입력이 일치하지 않을 때 출력이 1이 되는 회로) 연산을 한다.
^=

:: - 스코프 연산자. class안의 함수를 밖으로 빼낼 수 있음
-> - 역참조 연산자. 포인터 주소값을 직접들어가서 함수를 불러옴

typedef - 자료형 재정의. typedef + 변경하고자하는 자료형 + 변경할 자료형 이름;으로 사용
ex) typedef unsigned int UINT;
    UINT a = 30;


열거 타입
어떤 숫자들을 나열할지 프로그래머가 마음대로 정할 수 있게 해줌. 
enum으로 사용. 각 숫자들은 명시되지 않았을 경우 앞의 숫자에 1 증가한 값을 가짐.

엄격한 열거 타입(C++11 추가)
enum class로 사용. 타입을 바꿀 수 있으며, class이름으로 스코프 설정이 되지 않으면 참조 불가.


구조체
struct로 사용, 기본 타입 또는 다른 구조체를 조합하여 새로운 타입을 만들어냄. DB같은것을 표현 할 때 주로 사용


조건문
조건문은 주어진 표현식의 결과가 참인지 거짓인지에 따라 특정코드를 실행 할 수 있게 해준다.
if/else구문
switch구문
삼항연산자 - 조건 ? 참일경우 : 거짓일경우

조건연산자
<   - 작으면 참
<=  - 작거나 같으면 참
>   - 크면 참
>=  - 크거나 같으면 참
==  - 같으면 참
!=  - 다르면 참
!   - 참/거짓 반전
&&  - 둘다 참일경우에만 참
||  - 둘중 하나만 참일경우에 참

C++에서는 단락논리를 적용하여 남아있는 표현식들이 조건문의 최종 결과에 영향이 없을경우 전부 스킵함.



반복문
반복작업을 하는 명령어
while
do/while
for

(C++11추가) 구간 지정 루프
리스트를 순회하며 작업 할 때 편리하다. 리스트 그리고 반복자를 리턴하는 begin()/end()를 맴버로 사진
데이터 타입을 대상으로 한다.
ex)
int arr[] = {1,2,3,4}; 
for(auto& i : arr){
	i+=2;
}


배열
배열은 같은 데이터 타입의 값들을 일렬로 나열한것.
각 항목은 배열의 위치로 구분된다.
배열의 원소수를 명시하지 않으면 {}안의 데이터 개수에 따라 결정된다.

배열의 원소 : 배열의 포함된 값 한 개, 배열의 원소 한 개 구분할 때는 첨자(index)를 사용 

배열의 차원 : 1차원, 2차원, 3차원 등의 다차원 배열, 배열의 첨자의 개수와 동일

C++에서는 배열을 선언할 때 배열의 크기를 명시적으로 설명해야하며 이 때 값이 변하는 변수를 크기로 지정할수 없다.
그러나 C++11에서는 상수 표현식을 배열 크기 선언에 이용할 수 있다.

std::array(C++11추가)
<array>헤더에 정의 되어 있으며, C언어의 배열을 대체하는 (범위를 벗어난 잘못된 메모리 작업의 위험이 없는)
안전한 배열 타입이다. std::vector와는 달리 크기가 고정되어 있어 항목을 추가하거나 삭제 할 수는 없으나 오버헤드가 적다.
ex) array<int,3> arr = {9,8,7};


__func__(C++11추가)
static const char __func__[] = "함수이름"
호출 로그를 남겨야 할 때 등의 상황에서 함수이름을 리턴해줌
